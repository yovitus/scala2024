// Advanced Programming 2018
// Example exam solutions.
// Andrzej WÄ…sowski and Zhoulai Fu
//
// Note: many other solutions are often possible.  Also better solutions are
// possible sometimes, but not required for a top grade.

package adpro.exam2018solution

import fpinscala.monoids.Monoid
import fpinscala.monads.Monad
import fpinscala.monads.Functor
import fpinscala.laziness.{Stream,Empty,Cons}
import fpinscala.laziness.Stream._
import fpinscala.parallelism.Par._
import scala.language.higherKinds
import adpro.data._
import adpro.data.FingerTree._
import monocle.Lens


object Q1 {

  /**
   * Task 1: An association list is a List[(K,V)] storing pairs of values.  The
   * first element of each pair is a key (of type K), and the second element of
   * each pair is a value (of type V).  Implement a groupByKey operation for
   * association lists. Given an association list l that possibly has more than
   * one entry for each key k, it should produce an association list that has
   * exactly one entry for each key k, paired with a list of all the values
   * paired with k in the original list.
   *
   * For instance:
   *  groupByKey (List((1,1),(1,1),(1,2),(2,3)))
   * should produce
   *  List(1 -> List(1,1,2), 2 -> List(3))
   *
   * Don't use groupBy from the standard library and do not construct any maps
   * (instances of Map) in the process. The computational complexity of the
   * algorithm is not graded.  Simple solutions are appreciated.
   */


  // Quadratic (using a Map or sorted list, we can do this better, at least
  // O(n log n) or even O(n) expected time, but we did not ask for this. To
  // the contrary.  We want the examinee to perform some non-trivial folding.

  private def f[K,V] (l: List[(K,List[V])], z: (K,V)): List[(K,List[V])] = {
    val l1 = l map { e => if (e._1==z._1) e._1->(z._2::e._2) else e }
    if (l1 == l) (z._1->List(z._2))::l else l1
  }

  def groupByKey[K,V] (l :List[(K,V)]) :List[(K,List[V])] =
     l.foldLeft[List[(K,List[V])]] (Nil) (f)

}

object Q2 { // Weaving Either

  /**
   * Task 2: Recall that Either[A,B] represents an error (A) or a result of a
   * computation (B).  List[Either[A,B]] represents a list of computation
   * results.  Write a function f that converts this list to
   * Either[List[A],List[B]], where the first component represents a list of all
   * errors, if there were any, and the second component represents a list of
   * all good results (if all computations were successful).
   */

  def f[A,B] (results: List[Either[A,B]]) :Either[List[A],List[B]] =
    results collect { case Left(b) => b } match {
      case Nil =>  Right (results collect { case Right(a) => a })
      case failures => Left (failures)
    }

  // A solution with collect is nice because the types work, but one can also
  // work with map and filter etc.

}


object Q3 { // Monads and Either

  /**
   * Task 3: Implement a monad instance for Either[String,A]. This is equivalent
   * to  implementing the monad instance for the following type: T[B] =
   * Either[String,B]).  The instance should be right-biased, so should largely
   * follow the same behavior as Option, for instance, flatMap and map should
   * operate on instances of Right.
   *
   * You can use any function, including flatMap, from the standard library
   * implementation of Either
   * (https://www.scala-lang.org/api/current/scala/util/Either.html) or from the
   * book (fpinscala) implementation of Either. Of course, within our course
   * assumptions (pure, typed, etc.).
   */

    type T[B] = Either[String,B]
    implicit val eitherStringIsMonad :Monad[T] = new Monad[T] {
      override def unit[B] (b: => B) :Either[String,B] = Right(b)
      override def flatMap[B,C] (ea: Either[String,B]) (f: B => Either[String,C])
        : Either[String,C] = ea flatMap f
    }

  /**
   * Task 4: Now generalize this instance to work for any type A by creating an
   * implicit generator of instances of Monad[Either[A,B]] for any A.
   */

  implicit def eitherIsMonad[A] = {
    type T[B] = Either[A,B]
    new Monad[T] {
      override def unit[B] (b: => B) :Either[A,B] = Right(b)
      override def flatMap[B,C] (ea: Either[A,B]) (f: B => Either[A,C])
        : Either[A,C] = ea flatMap f
    }
  }

  // solution template

  // implicit def eitherIsMonad[A] = {
  //   type T[B] = Either[A,B]
  //   ???
  // }


}

object Q4 { // Streams and State

  /**
   * Task 5. Recall that we can take an automaton and translate its transition
   * relation to a stream of generated actions.  Consider the following automaton:
   *
   * State[(Int,Int),Int] { x => (x._1, (x._2,x._1+x._2)) }
   *
   * 1. What is the stream generated by this automaton if starting with  with
   *    (1,1) as the initial state? (answer in English and include an example
   *    prefix of 5 elements)
   *
   * 2. What is the state space (set of possible state values) of this
   *    automaton?
   *
   * 3. What is its action range (set of possible action values) ?
   *
   * Write the answers in English below.
   *
   * 1. The automaton generates Fibonacci numbers.  The state space contains
   *    two consecutive Fibonacci numbers, starting with (1,1) the first two
   *    numbers.  Each transition step produces the first of this numbers and
   *    advances the state to the next pair (dropping the first number, and
   *    adding a new second number produced by addition).  The prefix is:
   *
   *    1, 1, 2, 3, 5
   *
   * 2. The state space of the automaton are pairs of consecutive Fibonacci
   *    numbers (if starting with (1,1)). [pairs of integers]
   *
   * 3. The action range of the automaton are Fibonacci numbers. [positive
   *    integers, if starting with (1,1)]
   *
   */


}

object Q5 { // Par

  /**
   * Task 6.  Recall a function forall from the list interface:
   *
   * def forall[A] (l: List[A]) (p: A =>Boolean): Boolean
   *
   * It checks whether all elements of a list l satisfy the predicate p.
   *
   * Implement a function parForall that does the same in parallel: for a given
   * list of A s and a predicate p it checks which elements satisfy the
   * predicate in parallel.
   *
   */

  def parForall[A] (as: List[A]) (p: A => Boolean): Par[Boolean] = {
    val bs :Par[List[Boolean]] = parMap (as) (p)
    map[List[Boolean],Boolean] (bs) (bs => bs.foldRight (true) (_&&_))
  }

}


object Q6 { // Types and function values

  /**
   * Task 7: Recall that for a binary function f: (A,B) => C the function
   * f.curried is of type A => B => C. Assume the following type declarations:
   */

	def apply[F[_],A,B](fab: F[A => B])(fa: F[A]): F[B] = ???
  def unit[F[_],A](a: => A): F[A] = ???

  val f: (Int,Int) => Int = _ + _
  def a :List[Int] = ???

  /*
   * Let x be:
   *
   * val x = apply (apply (unit (f.curried)) (a)) (a)
   *
   * What is the type of x? Rest assured that the expression is type safe and
   * has a well-defined type (despite the type inference failing for it).
   */

  // answer:

  (apply (apply (unit (f.curried)) (a): List[Int=>Int]) (a) :List[Int])

  // so the short answer is List[Int]

}

object Q7 {
  /**
   * Task 8: Assume that a map2 function is implemented for lists:
   */
  def map2[A,B,C] (a :List[A], b: List[B]) (f: (A,B) => C): List[C] = ???

  /**
   * Implement map3 using map2 for lists:
   */
  def map3[A,B,C,D] (a :List[A], b: List[B], c: List[C]) (f: (A,B,C) => D) :List[D] =
    map2 (map2 (a,b) { case (a,b) => (a,b) }, c) { case ((a,b),c) => f (a,b,c) }

  /**
   * Task 9: Solve task 8 not for List but for arbitrary monad type constructor
   * M[_]. Make sure that your map3 requires that for M[_] an instance of Monad
   * exists, to ensure that map2 is available.
   */

  def map3monad[M[_]: Monad, A,B,C,D] (a :M[A], b: M[B], c: M[C]) (f: (A,B,C) => D) :M[D] =
    implicitly[Monad[M]].map2 (
      implicitly[Monad[M]].map2 (a,b) { case (a,b) => (a,b) }, c)
      { case ((a,b),c) => f (a,b,c) }

  def map3monad2[M[_], A,B,C,D] (a :M[A], b: M[B], c: M[C]) (f: (A,B,C) => D)
    (implicit evidence: Monad[M]): M[D] =
    evidence.map2 (
      evidence.map2 (a,b) { case (a,b) => (a,b) }, c)
      { case ((a,b),c) => f (a,b,c) }

}

object Q8 { // Finger Trees

  /**
   * Task 10: Implement a filter operation on Finger Trees.  The implementation
   * does not have to be efficient.  You can get full points for a simple,
   * inefficient implementation.  The FingerTree implemetation in Scala, used in
   * the course is included in this sbt project.  You can use any structures and
   * functions from the book or from the standard library.
   *
   * Only for MSEN + MSc.
   */

  def filter[A] (t: FingerTree[A]) (p: A => Boolean): FingerTree[A] =
    Digit.toTree (t.toList.filter(p))
}

object Q9 { // Lenses

  /**
   * Task 11: Implement a Lense viewing an instance of Either[A,B] as an
   * instance of Option[B].  This lense needs to use a default value, to fill in
   * for A, whenever puting back a None value.
   *
   * Only for MSc.
   */

  def eitherOption[A,B] (default: => A): Lens[Either[A,B],Option[B]] =
    Lens[Either[A,B],Option[B]]
    { c => c match { case Right(b) => Some(b)
                     case _ => None }  }
    { a => _ => a match { case Some(b) => Right(b)
                          case _ => Left(default) } }

  /**
   * Task 12.  Respond to the three following questions:
   *
   * 1. Does the above lense satisfy the put-get low, and why?
   *
   * 2. Does the above lense satisfy the get-put low, and why?
   *
   * 3. Does the above lense satisfy the put-put low, and why?
   *
   * If the answer is positive give an argument, if the answer is negative, give
   * a counter example.
   *
   * answers:
   *
   * 1. This lens satisfies the put-get low: the set function puts any b: B value
   *    into Right, which is extracted back to Some(b) using get.  If the
   *    abstract value is none, it is set into the Left value which is projected
   *    back to None by put.
   *
   * 2. set (get(Left(0))) (Left(0)) is Left(-1) so the law does not hold.
   *
   * 3. The put-put law holds because the set function ignores the concrete
   *    value entirely, so it always produces the same result for a given
   *    abstract value, regardless of whatever was performed before.
   *
   */

}


